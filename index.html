<!DOCTYPE html>
<html>

<head>
    <title>Modelo 3D en la web</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }

        #rot-x,
        #rot-y,
        #rot-z {
            position: absolute;
        }

        #rot-x {
            top: 10px;
            left: 5px;
        }

        #rot-y {
            top: 25px;
            left: 5px;
        }

        #rot-z {
            top: 40px;
            left: 5px;
        }
    </style>
</head>

<body>
    <!-- <input type="range" name="rot-x" id="rot-x" min="0" max="359"> -->
    <!-- <input type="range" name="rot-y" id="rot-y" min="0" max="359"> -->
    <!-- <input type="range" name="rot-z" id="rot-z" min="0" max="359"> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        function degToRad(degrees) {
            return degrees * (Math.PI / 180);
        }

        function radToDeg(radiants) {
            return radiants / (Math.PI / 180);
        }

        document.addEventListener("wheel", function () { console.log(camera.position.x, camera.position.y, camera.position.z) });

        // 1. Configurar la escena
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.0001, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. Añadir controles para que el usuario pueda interactuar
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // 3. Cargar modelos GLTF
        const loader = new THREE.GLTFLoader();

        loader.load('./PMI/pmi_huecos.glb', function (gltf) {
            let model = gltf.scene;

            model.position.set(0, 0, 0);
            model.scale.set(1, 1, 1);

            model.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshStandardMaterial({
                        color: 0x158F00,
                        metalness: 0,
                        roughness: 1
                    });
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            scene.add(model);
        }, undefined, function (error) {
            console.error(error);
        });
        loader.load('./PMI/pmi_infrastructura.glb', function (gltf) {
            let model = gltf.scene;

            model.position.set(0, 0, 0);
            model.scale.set(1, 1, 1);

            model.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshStandardMaterial({
                        color: 0xc0c0c0,
                        metalness: 0,
                        roughness: 1
                    });
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            scene.add(model);
        }, undefined, function (error) {
            console.error(error);
        });
        loader.load('./PMI/pmi_pista.glb', function (gltf) {
            let model = gltf.scene;

            model.position.set(0, 0, 0);
            model.scale.set(1, 1, 1);

            model.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshStandardMaterial({
                        color: 0x404040,
                        metalness: 0,
                        roughness: 1
                    });
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            scene.add(model);
        }, undefined, function (error) {
            console.error(error);
        });

        function add_A320(pos_x, pos_y, pos_z, rot_x, rot_y, rot_z) {
            // Retornamos una nueva Promesa
            return new Promise((resolve, reject) => {
                loader.load('./aviones/A320.glb', function (gltf) {
                    let model = gltf.scene;

                    model.position.set(pos_x, pos_y, pos_z);
                    model.rotation.x = degToRad(rot_x);
                    model.rotation.y = degToRad(rot_y);
                    model.rotation.z = degToRad(rot_z);
                    model.scale.set(0.005, 0.005, 0.005);

                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0x7575FF,
                                metalness: 0,
                                roughness: 1
                            });
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    scene.add(model);

                    // Cuando la carga y configuración terminan, resolvemos la Promesa con el modelo
                    resolve(model);

                }, undefined, function (error) {
                    console.error(error);
                    // Si hay un error, rechazamos la Promesa
                    reject(error);
                });
            });
        }

        // Aviones
        add_A320(
            0.025,  // p_x
            0.006,  // p_y
            0.2,    // p_z
            0,      // r_x
            270,    // r_x
            0       // r_x
        );
        add_A320(
            0.025,  // p_x
            0.006,  // p_y
            0.125,  // p_z
            0,      // r_x
            270,    // r_x
            0       // r_x
        );
        add_A320(
            0.24,   // p_x
            0.006,  // p_y
            0.325,  // p_z
            0,      // r_x
            180,      // r_x
            0       // r_x
        );
        add_A320(
            -1,     // p_x
            0.06,   // p_y
            -0.855, // z_x
            90,     // r_x
            262,    // r_x
            90      // r_x
        );
        add_A320(
            -0.01,  // p_x
            0.006,  // p_y
            0.83,   // p_z
            0,      // r_x
            257,    // r_x
            0       // r_x
        );
        add_A320(
            0.24,      // p_x
            0.006,  // p_y
            -0.3,      // p_z
            0,      // r_x
            180,    // r_x
            0       // r_x
        );
        add_A320(
            0.24,      // p_x
            0.006,  // p_y
            -0.61,      // p_z
            0,      // r_x
            160,    // r_x
            0       // r_x
        );
        add_A320(
            0.5,      // p_x
            0.006,  // p_y
            -0.63,      // p_z
            0,      // r_x
            90,    // r_x
            0       // r_x
        );
        add_A320(
            1.34,      // p_x
            0.006,  // p_y
            -0.78,      // p_z
            0,      // r_x
            160,    // r_x
            0       // r_x
        );
        add_A320(
            -0.45,  // p_x
            0.006,  // p_y
            0.29,    // p_z
            0,      // r_x
            270,    // r_x
            0       // r_x
        );
        add_A320(
            -0.45,  // p_x
            0.006,  // p_y
            0.36,    // p_z
            0,      // r_x
            270,    // r_x
            0       // r_x
        );
        add_A320(
            -0.56,  // p_x
            0.006,  // p_y
            0.475,    // p_z
            0,      // r_x
            180,    // r_x
            0       // r_x
        );
        add_A320(
            -0.731,  // p_x
            0.006,  // p_y
            0.475,    // p_z
            0,      // r_x
            180,    // r_x
            0       // r_x
        );
        add_A320(
            2.5,     // p_x
            0.06,   // p_y
            0.84, // z_x
            90,     // r_x
            262,    // r_x
            90      // r_x
        );

        var a320_1;
        async function inicializarEscena() {
            try {
                a320_1 = await add_A320(-1, 0.06, -0.855, 0, 0, 0);
                document.getElementById("rot-x").addEventListener("input", function () {
                    a320_1.rotation.x = degToRad(document.getElementById("rot-x").value);
                    console.log("X = " + radToDeg(a320_1.rotation.x) + "\nY = " + radToDeg(a320_1.rotation.y) + "\nZ = " + radToDeg(a320_1.rotation.z));
                })
                document.getElementById("rot-y").addEventListener("input", function () {
                    a320_1.rotation.y = degToRad(document.getElementById("rot-y").value);
                    console.log("X = " + radToDeg(a320_1.rotation.x) + "\nY = " + radToDeg(a320_1.rotation.y) + "\nZ = " + radToDeg(a320_1.rotation.z));
                })
                document.getElementById("rot-z").addEventListener("input", function () {
                    a320_1.rotation.z = degToRad(document.getElementById("rot-z").value);
                    console.log("X = " + radToDeg(a320_1.rotation.x) + "\nY = " + radToDeg(a320_1.rotation.y) + "\nZ = " + radToDeg(a320_1.rotation.z));
                })

            } catch (error) {
                console.error("Error al cargar el modelo:", error);
            }
        }

        //inicializarEscena();


        // 4. Añadir iluminación

        // DEV NOTES: para las farolas y los focos, utilizar spotlight

        const light = new THREE.AmbientLight(0xffffff, 0.55);
        scene.add(light);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);

        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;

        directionalLight.position.set(1, 10, 2);
        scene.add(directionalLight);

        // 5. Posicionar la cámara
        //camera.position.x = -2;
        //camera.position.y = 0.3;
        //camera.position.z = 1;

        camera.position.x = 0;
        camera.position.y = 2.3;
        camera.position.z = 0;

        scene.background = new THREE.Color(0x303030);

        // 6. Bucle de animación
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>

</html>